# LinkLab 2025：构建你自己的链接器

```
 ___       ___  ________   ___  __    ___       ________  ________
|\  \     |\  \|\   ___  \|\  \|\  \ |\  \     |\   __  \|\   __  \
\ \  \    \ \  \ \  \\ \  \ \  \/  /|\ \  \    \ \  \|\  \ \  \|\ /_
 \ \  \    \ \  \ \  \\ \  \ \   ___  \ \  \    \ \   __  \ \   __  \
  \ \  \____\ \  \ \  \\ \  \ \  \\ \  \ \  \____\ \  \ \  \ \  \|\  \
   \ \_______\ \__\ \__\\ \__\ \__\\ \__\ \_______\ \__\ \__\ \_______\
    \|_______|\|__|\|__| \|__|\|__| \|__|\|_______|\|__|\|__|\|_______|
```

> 每个程序员都用过链接器，但很少有人真正理解它。
>
> 在这个实验中，你将亲手实现一个链接器，揭开程序是如何被「拼接」在一起的秘密。我们设计了一个友好的目标文件格式（FLE），让你可以专注于理解链接的核心概念。

> [!WARNING]
> 如果你：
>
> - 发现了 Bug，请[提交 Issue](https://github.com/RUCICS/LinkLab-2024-Assignment/issues)
> - 有任何 Question，请在[讨论区](https://github.com/RUCICS/LinkLab-2024-Assignment/discussions)提出
>
> 也欢迎你积极参与开源协作，改进框架代码解决 Issue、或是为同学们答疑解惑。这部分的表现可被计为[额外的分数](#评分标准)。

> [!NOTE]
> 本实验预计耗时 10 - 20 个小时，具体情况因个体差异可能有所区别。

[![GitHub Issues](https://img.shields.io/github/issues/RUCICS/LinkLab-2024-Assignment?style=for-the-badge&logo=github)](https://github.com/RUCICS/LinkLab-2024-Assignment/issues)

## 什么是链接？

链接是将多个目标文件组合成一个可执行程序的过程。在现代软件开发中，我们不会把所有代码都写在一个文件里——这样既不利于代码复用，也不便于团队协作。相反，我们会将程序分解成多个源文件，分别编译成目标文件，再通过链接器将它们「拼接」在一起。

问题在于，编译器在处理每个文件时，只能看到当前文件的内容。当代码调用另一个文件中定义的函数，或者访问另一个文件中的全局变量时，编译器并不知道那个函数或变量最终会在内存的什么位置。它只能在目标文件中留下一个"占位符"，标记这里需要一个地址，等待链接器来填充。

这就是链接器的工作。它接收多个目标文件作为输入，每个目标文件都包含一些代码和数据，以及关于符号定义和引用的信息。链接器需要把这些信息综合起来，解决所有的依赖关系，确定每个符号的最终位置，然后将正确的地址填入那些占位符中。

具体来说，链接器需要完成三项核心工作：

- **符号解析**。程序中的每个函数、每个全局变量都有一个名字，这个名字就是符号。链接器需要建立一个全局的视图，知道每个符号在哪里定义，确保每个被引用的符号都能找到它的定义。当两个文件定义了同名符号时，链接器还需要按照一定的规则决定使用哪一个，或者判断这是一个错误并报告给程序员。
- **重定位**。确定了符号的位置后，链接器需要回到代码中，将那些占位符替换成实际的地址。这个过程叫做重定位。不同类型的引用需要不同的处理方式——函数调用可能使用相对地址，访问全局变量可能使用绝对地址，指针赋值可能需要完整的64位地址。链接器需要理解这些差异，并正确计算和填充每个位置。
- **内存布局规划**。现代程序不仅需要正确运行，还需要安全运行。链接器需要决定程序的各个部分在内存中如何排列，为代码和数据分配合适的位置，设置访问权限以防止意外或恶意的修改。代码应该是可执行但不可写的，数据应该是可读写但不可执行的，常量应该是只读的。这些约束共同构成了程序的安全边界。

在这个实验中，你将逐步实现这些功能。从最基本的符号表查看开始，到能够处理简单程序的链接器，再到支持各种重定位类型、符号决议规则、内存保护机制的完整链接器，最终深入理解现代程序是如何被组装起来的。

## 环境要求

- 操作系统：Linux（推荐 Ubuntu 22.04 或更高版本）
  - Windows 用户可考虑使用 WSL 2
- 编译器：支持 C++17
  - g++-8 及以上，推荐使用最新版本
  - clang 的较新版本
- Python 3.6+
- Make, Git

请使用 Git 管理你的代码，并养成经常提交的好习惯。这不仅能保护你的工作成果，也能让你在需要时回退到之前的版本。

## 快速开始

```bash
# 克隆仓库（请将 your-assignment-repo-url 替换为你的仓库地址）
git clone your-assignment-repo-url
cd your-assignment-repo-name

# 构建项目
make

# 运行测试（此时应该会失败，这是正常的）
make test_1  # 运行任务一的测试
make test    # 运行所有测试
```

## 项目结构

```
LinkLab-2025/
├── include/                  # 头文件
│   └── fle.hpp               # FLE 格式定义（请仔细阅读）
├── src/
│   ├── base/                 # 基础框架（助教提供）
│   │   ├── cc.cpp            # 编译器前端，生成 FLE 文件
│   │   └── exec.cpp          # 程序加载器，运行生成的程序
│   │   └── ar.cpp            # 归档器，生成目标文件
│   └── student/              # 你需要完成的代码
│       ├── nm.cpp            # 任务一：符号表查看器
│       └── ld.cpp            # 任务二~八：链接器主程序
└── tests/                    # 测试用例
    └── cases/                # 按任务分类的测试
        ├── 1-nm-test/        # 任务一：符号表显示
        ├── 2-single-file/    # 任务二：基础链接
        └── ...               # 更多测试用例
    └── common/               # 测试用例的公共库
        └── minilibc.c        # 迷你 libc 的实现
```

每个任务都配有完整的测试用例，包括源代码、期望输出和配置文件。你可以阅读测试代码了解具体要求，运行测试检查实现是否正确，也可以编写新的测试用例来探索更多可能性。

## 实验任务

### 任务零：理解目标文件格式

在开始编写代码之前，你需要理解链接器处理的数据格式。本实验使用FLE（Friendly Linking Executable）格式——一个简化的、人类可读的目标文件格式。这个任务会介绍FLE文件的结构、表情符号标记的含义、以及文件表示与内存结构之间的对应关系。特别重要的是理解符号、重定位、节与段等核心概念。

📖 [详细指导](docs/task0.md)

### 任务一：实现符号表查看工具

实现`nm`命令的功能，显示目标文件中的符号表。这个工具需要遍历符号列表，判断每个符号的类型（全局/局部/弱符号）和位置（代码段/数据段/BSS段等），然后按照标准格式输出。

**你需要实现**：`src/student/nm.cpp`中的`FLE_nm`函数

**测试命令**：`make test_1`

📖 [详细指导](docs/task1.md)

### 任务二：实现基础链接器

实现一个能够处理简单场景的链接器。给定若干目标文件，将它们的节内容合并，建立全局符号表，处理绝对重定位（`R_X86_64_32`和`R_X86_64_32S`），最后生成可执行文件。这个阶段可以将所有内容放在一个内存段中，不需要考虑权限分离。

**你需要实现**：`src/student/ld.cpp`中的`FLE_ld`函数的基础框架

**测试命令**：`make test_2`

📖 [详细指导](docs/task2.md)

### 任务三：处理多种地址引用方式

扩展链接器以支持PC相对寻址（`R_X86_64_PC32`，用于函数调用）和64位绝对寻址（`R_X86_64_64`，用于指针）。相对寻址的计算涉及当前位置和目标位置的偏移，需要理解x86-64指令格式的细节。

**你需要实现**：在任务二的基础上，增加对新重定位类型的处理

**测试命令**：`make test_3`

📖 [详细指导](docs/task3.md)

### 任务四：处理符号冲突

实现符号决议规则。当多个目标文件定义同名符号时，链接器需要判断这是否合法，以及应该使用哪个定义。规则包括：强符号必须唯一，强符号覆盖弱符号，多个弱符号可以共存。此外还需要正确处理局部符号，确保不同文件的同名局部符号不会混淆。

**你需要实现**：扩展符号解析逻辑，增加冲突检测和决议

**测试命令**：`make test_4`

📖 [详细指导](docs/task4.md)

### 任务五：代码与数据的分离

将程序的内存布局从单段改为多段。将代码（`.text`及其变体）和数据（其他所有节）分别放入不同的段，为每个段创建独立的程序头。这是向内存保护机制迈出的第一步，虽然此阶段暂时不设置不同的权限。

**你需要实现**：修改节合并和程序头生成逻辑，支持多段布局

**测试命令**：`make test_5`

📖 [详细指导](docs/task5.md)

### 任务六：引入只读数据段

进一步细化内存布局，为只读数据（`.rodata`及其变体）创建独立的段。现在程序有三个段：代码段、只读数据段、可读写数据段。这种分类为后续的权限设置做准备。

**你需要实现**：扩展节分类逻辑，为只读数据创建独立的段

**测试命令**：`make test_6`

📖 [详细指导](docs/task6.md)

### 任务七：完善内存保护机制

为每个段设置正确的访问权限：代码段只读可执行，只读数据段只读，可读写数据段可读写但不可执行。实现段对齐以满足操作系统的页管理要求。正确处理`.bss`节，使其在文件中不占用空间，但在运行时分配相应的内存。

**你需要实现**：设置程序头的权限标志，实现段对齐，特殊处理BSS节

**测试命令**：`make test_7`

📖 [详细指导](docs/task7.md)

### 任务八：静态链接库

实现对静态库（归档文件）的支持。静态库包含多个目标文件，链接器应该只提取程序实际使用的那些目标文件，而不是全部包含。这需要实现按需链接算法：迭代地解析符号引用，从库中提取相关的目标文件，直到所有符号都被解析或确认为未定义。

**你需要实现**：扩展`FLE_ld`以识别和处理归档文件输入

**测试命令**：`make test_8`

📖 [详细指导](docs/task8.md)

### Bonus 1：生成共享库（选做）

实现生成共享库的能力。与静态链接不同，共享库中对外部符号的引用需要保留到运行时解析。这个任务要求理解位置无关代码的概念，生成动态符号表导出库中的符号，并保留未解析的重定位信息供加载器使用。

**你需要实现**：修改链接流程以生成`.so`类型的输出，处理动态符号和运行时重定位

**测试命令**：`make test_bonus1`

📖 [详细指导](docs/bonus1.md)

### Bonus 2：链接使用共享库的程序（选做）

实现链接到共享库的可执行文件。程序通过全局偏移表（GOT）间接访问共享库中的符号，链接器需要创建GOT，将对外部符号的引用重定向到GOT条目，并生成动态重定位表告诉加载器如何填充GOT。

**你需要实现**：创建和管理GOT，生成动态重定位表，记录依赖的共享库

**测试命令**：`make test_bonus2`

📖 [详细指导](docs/bonus2.md)

## 完成本实验

### 实验报告

请参考[报告模板通用指南](./report/README.md)，基于[实验报告模板](./report/report.md)，完成实验报告。

### 提交

使用 GitHub Classroom 进行提交。请你确保所有代码已提交到你的对应仓库，GitHub Actions 会自动运行测试，其输出作为我们的评分依据。

### 评分标准

分数由**正确性评分**和**质量评分**两部分组成，正确性评分占 60%，质量评分占 40%，即：

$$
\text{总分} = \frac{\text{正确性评分}} {\text{正确性满分}} \times 60\% + \text{质量评分} \times 40\%
$$

其中，正确性评分由 GitHub Classroom 自动计算，质量评分由助教根据代码风格和实验报告综合评估，具体衡量因素为：

- 代码风格
  - 代码表达能力强，逻辑清晰，代码简洁，**仅在必要时**添加注释
  - 防御性编程，进行多层次的错误检查
  - 如果你使用 C++ 风格进行编码，请积极使用 C++ 标准库，而非重复造轮子
- 实验报告
  - 实验报告内容完整、格式规范、结构清晰
  - 实验报告内容与代码一致，无明显矛盾，体现出对实验考察知识的基本了解
  - 有思考，有总结，有反思，有创新
  - 对实验提供有价值的反馈和建议，积极参与开源协作

### 调试建议

你可以阅读[调试指南](docs/debug.md)，了解如何使用评测脚本和 VSCode 调试。

### 关于学术诚信

这个实验的核心价值在于你自己动手实现链接器的过程，并以此祛除对底层系统的恐惧感。参考资料、讨论问题、寻求思路上的启发都是正常的学习方式，但直接复制他人的代码——无论是从同学、网络还是其他任何来源——都违背了实验的初衷。

为了维护课程的公平性，我们会使用基于 AST（抽象语法树）的代码查重系统。该系统能识别代码逻辑结构的相似性，变量重命名或格式调整无法避开检测。一旦确认存在实质性的抄袭，我们将不得不根据学校相关规定进行严肃处理。

如果你在实验中遇到了持续的、真正的困难，请及时在讨论区提问或联系助教。我们在设计实验时已经考虑了难度的渐进性，但如果某个地方确实存在理解上的断层，我们非常乐意为你提供思路上的引导，帮助你跨越障碍。

### 关于 AI 工具使用

大语言模型和编程助手正在改变软件开发的方式，我们鼓励你**明智地**使用它们。

AI 工具最有价值的用法是帮助你理解概念、解释错误信息、提供调试思路。比如，当你在文档中看到晦涩的术语，或者面对编译器报出的复杂错误不知所措时，AI 是极好的解释者。当你对某个模块的设计犹豫不决时，与 AI 探讨不同方案的优劣也是很好的思维训练。

但如果你直接让 AI 生成整个函数或大段代码，然后不加理解地使用它，这会产生两个严重的问题：
1. 链接器是一个高度耦合的系统，各个模块之间存在紧密的依赖。如果关键逻辑不是由你亲自构建，你很难建立起完整的心理模型，导致在后续调试或扩展功能时寸步难行。
2. 如果你对代码的实现细节不够理解，这会体现在实验报告中——你可能无法清晰地解释自己的设计决策，或者报告的内容与代码实现不一致。

实验报告是展示你理解程度的重要途径。报告应该用你自己的语言，描述你的实现思路、遇到的问题和解决方案、对实验的反思。相比于四平八稳但缺乏个人见解的技术文档，我们更看重带有个人印记的真实记录。

最终的评分由代码正确性、代码质量和实验报告共同决定。我们看重的是“真实”。如果我们发现你的代码表现与你的理解深度存在显著落差，这将直接反映在你的质量评分中。

## 进阶内容

> [!TIP]
> 前面的区域以后再来探索吧！

在完成基础任务的旅程之后，更广阔的天地正等待我们去探索。现代链接器早已超越了简单的代码组合，它需要在性能、兼容性、安全性等多个维度上进行取舍（trade-off），以满足复杂软件系统的需求。

以下是一些值得探索的方向，学有余力的同学可以尝试实现：

1. 静态库支持：通过设计一种归档格式（`.a` 文件）来打包多个目标文件，你的链接器可以实现按需链接——只提取程序实际使用的符号所在的目标文件。这不仅节省了磁盘空间，更重要的是避免了不必要的代码段被加载到内存。

2. 动态链接支持：它允许多个进程共享同一份代码，显著降低内存占用。要支持动态链接，你需要生成位置无关可执行文件（PIE），实现全局偏移表（GOT）处理数据引用，以及通过过程链接表（PLT）实现延迟符号绑定。此外，动态链接器还需要处理复杂的符号解析规则和加载时重定位。

3. 符号版本管理：对于维护长期支持的共享库至关重要。通过版本脚本，你可以为每个导出符号指定版本信息，实现多版本共存。这使得库可以在增加新功能的同时保持对旧版本 ABI 的兼容，避免「共享库依赖地狱」。你需要设计版本定义的语法，并在符号解析时正确处理版本信息。

4. 增量链接：着眼于提升开发效率。通过只重新链接发生变化的部分，可以大幅缩短构建时间。这需要你设计一个依赖图来追踪文件间的关系，并能够准确判断符号级别的变化。你还需要考虑如何处理调试信息的增量更新。

5. 调试支持：工程实践中不可或缺的功能。除了保留基本的符号表，完整的调试支持还需要处理 DWARF 格式的调试信息，包括行号表、变量描述、类型信息等。这些信息需要在链接过程中被正确重定位和合并。此外，为了让开发者能够使用 GDB 等标准调试工具，你还需要编写 GDB 脚本来支持 FLE 格式文件的解析，使调试器能够正确显示源码位置、变量值和调用栈等信息。

6. 安全增强：通过支持地址空间随机化（ASLR）和生成位置无关可执行文件（PIE），可以有效防范缓冲区溢出和代码注入攻击。此外，你还可以支持 RELRO（RELocation Read-Only）机制，将 GOT 表设为只读来防止 GOT 表覆写攻击。

这些探索不会被计入评分，但它们承载着更深远的意义。如果你愿意，可以通过 Pull Request 分享你的实现和对实验框架的改进。你的贡献将如涟漪般荡开，让更多追寻技术之美的同学从中受益。

## Acknowledgements

本实验由 22 级图灵班的李知非同学和彭文博同学共同提出并设计完成。在实验设计过程中，21 级图灵班的潘俊达同学为实验文档的编写提供了诸多建设性的建议，在此表示衷心的感谢。

特别感谢柴云鹏教授和王晶教授对本实验的悉心指导与大力支持。他们的专业见解和宝贵建议对实验的完善起到了重要的推动作用。

## 参考资料

1. [可执行文件和加载 - 操作系统（2025春）- jyy](https://jyywiki.cn/OS/2024/lect19.md)
2. [I Executable and Linkable Format (ELF)](https://www.cs.cmu.edu/afs/cs/academic/class/15213-f00/docs/elf.pdf)
3. [CSAPP: Computer Systems A Programmer's Perspective](https://csapp.cs.cmu.edu/)
4. [System V ABI](https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf)
5. [Linkers & Loaders](https://linker.iecc.com/)
6. [How To Write Shared Libraries](https://www.akkadia.org/drepper/dsohowto.pdf)
